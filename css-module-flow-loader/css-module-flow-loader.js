const path = require('path');
const fileSystem = require('fs');

const recursive = require('recursive-readdir');
const sass = require('node-sass');

const fileExtensionList = new Set(['.css', '.scss', '.sass']);
const excludeFolderList = new Set(['node_modules', '.git']);

function fileFilter(pathToFile, stats) {
    if (stats.isDirectory()) {
        return false;
    }

    const filePathChunkList = new Set(pathToFile.split(path.sep));

    // eslint-disable-next-line no-loops/no-loops
    for (const excludeFolder of excludeFolderList) {
        if (filePathChunkList.has(excludeFolder)) {
            return true;
        }
    }

    const extname = path.extname(pathToFile);

    return !fileExtensionList.has(extname);
}

const classListReplaceValue = '{{class-list}}';

const templateWrapper = `// @flow strict
/* This file is automatically generated by css-module-flow-loader */
declare module.exports: {|
${classListReplaceValue}
|};
`;

function rawClassNameToFlowProperty(rawClassName) {
    const className = rawClassName.replace(/[\s.:{]/g, '');

    return `    +'${className}': string;`;
}

function getFlowTypeFileContent(allRawClassNameList) {
    const allClassNameList = [...new Set(allRawClassNameList)].map(rawClassNameToFlowProperty);

    const uniqClassNameList = [...new Set(allClassNameList)];

    return templateWrapper.replace(classListReplaceValue, uniqClassNameList.join('\n'));
}

function writeFlowType(pathToFile) {
    sass.render(
        {
            file: pathToFile,
        },
        function sassRenderCallback(sassRenderError, result) {
            if (sassRenderError) {
                console.error(sassRenderError.message);
                return;
            }

            const allRawClassNameList = result.css.toString().match(/\.([_a-z]+[\w-_]*)[\s#,.:>{]*/gim);

            if (!allRawClassNameList) {
                return;
            }

            fileSystem.writeFile(
                result.stats.entry + '.flow',
                getFlowTypeFileContent(allRawClassNameList),
                function fileWriteCallback(fileWriteError) {
                    if (fileWriteError) {
                        console.error(fileWriteError.message);
                        return;
                    }

                    console.log('[css-module-flow-loader]:', pathToFile + '.flow has been updated.');
                }
            );
        }
    );
}

module.exports = function cssModuleFlowLoader(source) {
    const rootPathFolder = this.rootContext;

    recursive(rootPathFolder, [fileFilter])
        .then(filePathList => {
            filePathList.forEach(writeFlowType);

            return null;
        })
        .catch(recursiveFileFinderError => {
            console.error(recursiveFileFinderError.message);

            return recursiveFileFinderError;
        });

    return source;
};
